"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[691],{5883:function(e,t,o){let n;o.d(t,{FV:function(){return n2},Wh:function(){return nX},cn:function(){return nQ},nZ:function(){return n0},sJ:function(){return n1}});var r,i,a,l,s=o(2265),u=o(4887),c=o(5566),Recoil_err=function(e){let t=Error(e);if(void 0===t.stack)try{throw t}catch(e){}return t},Recoil_isPromise=function(e){return!!e&&"function"==typeof e.then},Recoil_nullthrows=function(e,t){if(null!=e)return e;throw Recoil_err(null!=t?t:"Got unexpected null or undefined")};function _defineProperty(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}let BaseLoadable=class BaseLoadable{getValue(){throw Recoil_err("BaseLoadable")}toPromise(){throw Recoil_err("BaseLoadable")}valueMaybe(){throw Recoil_err("BaseLoadable")}valueOrThrow(){throw Recoil_err(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw Recoil_err("BaseLoadable")}promiseOrThrow(){throw Recoil_err(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw Recoil_err("BaseLoadable")}errorOrThrow(){throw Recoil_err(`Loadable expected error, but in "${this.state}" state`)}is(e){return e.state===this.state&&e.contents===this.contents}map(e){throw Recoil_err("BaseLoadable")}};let ValueLoadable=class ValueLoadable extends BaseLoadable{constructor(e){super(),_defineProperty(this,"state","hasValue"),_defineProperty(this,"contents",void 0),this.contents=e}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(e){try{let t=e(this.contents);return Recoil_isPromise(t)?loadableWithPromise(t):isLoadable(t)?t:loadableWithValue(t)}catch(t){return Recoil_isPromise(t)?loadableWithPromise(t.next(()=>this.map(e))):loadableWithError(t)}}};let ErrorLoadable=class ErrorLoadable extends BaseLoadable{constructor(e){super(),_defineProperty(this,"state","hasError"),_defineProperty(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(e){return this}};let LoadingLoadable=class LoadingLoadable extends BaseLoadable{constructor(e){super(),_defineProperty(this,"state","loading"),_defineProperty(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(e){return loadableWithPromise(this.contents.then(t=>{let o=e(t);if(isLoadable(o))switch(o.state){case"hasValue":case"loading":return o.contents;case"hasError":throw o.contents}return o}).catch(t=>{if(Recoil_isPromise(t))return t.then(()=>this.map(e).contents);throw t}))}};function loadableWithValue(e){return Object.freeze(new ValueLoadable(e))}function loadableWithError(e){return Object.freeze(new ErrorLoadable(e))}function loadableWithPromise(e){return Object.freeze(new LoadingLoadable(e))}function loadableLoading(){return Object.freeze(new LoadingLoadable(new Promise(()=>{})))}function loadableAll(e){let t=Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t]),o=t.map(e=>isLoadable(e)?e:Recoil_isPromise(e)?loadableWithPromise(e):loadableWithValue(e)),n=o.every(e=>"hasValue"===e.state)?loadableWithValue(o.map(e=>e.contents)):o.some(e=>"hasError"===e.state)?loadableWithError(Recoil_nullthrows(o.find(e=>"hasError"===e.state),"Invalid loadable passed to loadableAll").contents):loadableWithPromise(Promise.all(o.map(e=>e.contents)));return Array.isArray(e)?n:n.map(t=>Object.getOwnPropertyNames(e).reduce((e,o,n)=>({...e,[o]:t[n]}),{}))}function isLoadable(e){return e instanceof BaseLoadable}var d={loadableWithValue,loadableWithError,loadableWithPromise,loadableLoading,loadableAll,isLoadable,RecoilLoadable:{of:e=>Recoil_isPromise(e)?loadableWithPromise(e):isLoadable(e)?e:loadableWithValue(e),error:e=>loadableWithError(e),loading:()=>loadableLoading(),all:loadableAll,isLoadable}},f=Object.freeze({__proto__:null,loadableWithValue:d.loadableWithValue,loadableWithError:d.loadableWithError,loadableWithPromise:d.loadableWithPromise,loadableLoading:d.loadableLoading,loadableAll:d.loadableAll,isLoadable:d.isLoadable,RecoilLoadable:d.RecoilLoadable});let h={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function Recoil_gkx_OSS(e){return h.RECOIL_GKS_ENABLED.has(e)}void 0!==c&&(null==c?void 0:c.env)!=null&&(function(e,t){var o,n;let r=null===(o=c.env[e])||void 0===o?void 0:null===(n=o.toLowerCase())||void 0===n?void 0:n.trim();if(null!=r&&""!==r){if(!["true","false"].includes(r))throw Recoil_err(`process.env.${e} value must be 'true', 'false', or empty: ${r}`);t("true"===r)}}("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",e=>{h.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=e}),function(e,t){var o;let n=null===(o=c.env[e])||void 0===o?void 0:o.trim();null!=n&&""!==n&&t(n.split(/\s*,\s*|\s+/))}("RECOIL_GKS_ENABLED",e=>{e.forEach(e=>{h.RECOIL_GKS_ENABLED.add(e)})})),Recoil_gkx_OSS.setPass=e=>{h.RECOIL_GKS_ENABLED.add(e)},Recoil_gkx_OSS.setFail=e=>{h.RECOIL_GKS_ENABLED.delete(e)},Recoil_gkx_OSS.clear=()=>{h.RECOIL_GKS_ENABLED.clear()};var Recoil_recoverableViolation=function(e,t,{error:o}={}){return null};let p=null!==(i=s.createMutableSource)&&void 0!==i?i:s.unstable_createMutableSource,_=null!==(a=s.useMutableSource)&&void 0!==a?a:s.unstable_useMutableSource,R=null!==(l=s.useSyncExternalStore)&&void 0!==l?l:s.unstable_useSyncExternalStore,S=!1;var y={createMutableSource:p,useMutableSource:_,useSyncExternalStore:R,currentRendererSupportsUseSyncExternalStore:function(){var e;let{ReactCurrentDispatcher:t,ReactCurrentOwner:o}=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,n=null!==(e=null==t?void 0:t.current)&&void 0!==e?e:o.currentDispatcher,r=null!=n.useSyncExternalStore;return!R||r||S||(S=!0,Recoil_recoverableViolation("A React renderer without React 18+ API support is being used with React 18+.")),r},reactMode:function(){return Recoil_gkx_OSS("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:Recoil_gkx_OSS("recoil_sync_external_store")&&null!=R?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:Recoil_gkx_OSS("recoil_mutable_source")&&null!=_&&"undefined"!=typeof window&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?Recoil_gkx_OSS("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:Recoil_gkx_OSS("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}},isFastRefreshEnabled:function(){return!1}};let AbstractRecoilValue=class AbstractRecoilValue{constructor(e){_defineProperty(this,"key",void 0),this.key=e}toJSON(){return{key:this.key}}};let RecoilState=class RecoilState extends AbstractRecoilValue{};let RecoilValueReadOnly=class RecoilValueReadOnly extends AbstractRecoilValue{};var m={AbstractRecoilValue,RecoilState,RecoilValueReadOnly,isRecoilValue:function(e){return e instanceof RecoilState||e instanceof RecoilValueReadOnly}},v=Object.freeze({__proto__:null,AbstractRecoilValue:m.AbstractRecoilValue,RecoilState:m.RecoilState,RecoilValueReadOnly:m.RecoilValueReadOnly,isRecoilValue:m.isRecoilValue}),Recoil_expectationViolation=function(e,...t){},Recoil_mapIterable=function(e,t){return function*(){let o=0;for(let n of e)yield t(n,o++)}()};let{isFastRefreshEnabled:g}=y;let DefaultValue=class DefaultValue{};let b=new DefaultValue,T=new Map,w=new Map;let NodeMissingError=class NodeMissingError extends Error{};let E=new Map;function getConfigDeletionHandler(e){return E.get(e)}var A={nodes:T,recoilValues:w,registerNode:function(e){h.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&function(e){if(T.has(e)){let t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}(e.key),T.set(e.key,e);let t=null==e.set?new v.RecoilValueReadOnly(e.key):new v.RecoilState(e.key);return w.set(e.key,t),t},getNode:function(e){let t=T.get(e);if(null==t)throw new NodeMissingError(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return T.get(e)},deleteNodeConfigIfPossible:function(e){var t,o;if(!Recoil_gkx_OSS("recoil_memory_managament_2020"))return;let n=T.get(e);null!=n&&null!==(t=n.shouldDeleteConfigOnRelease)&&void 0!==t&&t.call(n)&&(T.delete(e),null===(o=getConfigDeletionHandler(e))||void 0===o||o(),E.delete(e))},setConfigDeletionHandler:function(e,t){Recoil_gkx_OSS("recoil_memory_managament_2020")&&(void 0===t?E.delete(e):E.set(e,t))},getConfigDeletionHandler,recoilValuesForKeys:function(e){return Recoil_mapIterable(e,e=>Recoil_nullthrows(w.get(e)))},NodeMissingError,DefaultValue,DEFAULT_VALUE:b},N=(function(e){var t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},o={},n={},constant=function(e){return function(){return e}},r=o.hash=function(e){var o=void 0===e?"undefined":t(e);if("number"===o)return e;"string"!==o&&(e+="");for(var n=0,r=0,i=e.length;r<i;++r)n=(n<<5)-n+e.charCodeAt(r)|0;return n},hashFragment=function(e,t){return t>>>e&31},toBitmap=function(e){return 1<<e},fromBitmap=function(e,t){var o;return o=e&t-1,o-=o>>1&1431655765,o=(o=(858993459&o)+(o>>2&858993459))+(o>>4)&252645135,o+=o>>8,127&(o+=o>>16)},arrayUpdate=function(e,t,o,n){var r=n;if(!e){var i=n.length;r=Array(i);for(var a=0;a<i;++a)r[a]=n[a]}return r[t]=o,r},arraySpliceOut=function(e,t,o){var n=o.length-1,r=0,i=0,a=o;if(e)r=i=t;else for(a=Array(n);r<t;)a[i++]=o[r++];for(++r;r<=n;)a[i++]=o[r++];return e&&(a.length=n),a},arraySpliceIn=function(e,t,o,n){var r=n.length;if(e){for(var i=r;i>=t;)n[i--]=n[i];return n[t]=o,n}for(var a=0,l=0,s=Array(r+1);a<t;)s[l++]=n[a++];for(s[t]=o;a<r;)s[++l]=n[a++];return s},i={__hamt_isEmpty:!0},isEmptyNode=function(e){return e===i||e&&e.__hamt_isEmpty},Leaf=function(e,t,o,n){return{type:1,edit:e,hash:t,key:o,value:n,_modify:Leaf__modify}},Collision=function(e,t,o){return{type:2,edit:e,hash:t,children:o,_modify:Collision__modify}},IndexedNode=function(e,t,o){return{type:3,edit:e,mask:t,children:o,_modify:IndexedNode__modify}},ArrayNode=function(e,t,o){return{type:4,edit:e,size:t,children:o,_modify:ArrayNode__modify}},expand=function(e,t,o,n,r){for(var i=[],a=n,l=0,s=0;a;++s)1&a&&(i[s]=r[l++]),a>>>=1;return i[t]=o,ArrayNode(e,l+1,i)},pack=function(e,t,o,n){for(var r=Array(t-1),i=0,a=0,l=0,s=n.length;l<s;++l)if(l!==o){var u=n[l];u&&!isEmptyNode(u)&&(r[i++]=u,a|=1<<l)}return IndexedNode(e,a,r)},mergeLeaves=function mergeLeaves(e,t,o,n,r,i){if(o===r)return Collision(e,o,[i,n]);var a=hashFragment(t,o),l=hashFragment(t,r);return IndexedNode(e,toBitmap(a)|toBitmap(l),a===l?[mergeLeaves(e,t+5,o,n,r,i)]:a<l?[n,i]:[i,n])},updateCollisionList=function(e,t,o,r,i,a,l,s){for(var u=i.length,c=0;c<u;++c){var d=i[c];if(o(l,d.key)){var f=d.value,h=a(f);if(h===f)return i;if(h===n)return--s.value,arraySpliceOut(e,c,i);return arrayUpdate(e,c,Leaf(t,r,l,h),i)}}var p=a();return p===n?i:(++s.value,arrayUpdate(e,u,Leaf(t,r,l,p),i))},canEditNode=function(e,t){return e===t.edit},Leaf__modify=function(e,t,o,r,a,l,s){if(t(l,this.key)){var u=r(this.value);return u===this.value?this:u===n?(--s.value,i):canEditNode(e,this)?(this.value=u,this):Leaf(e,a,l,u)}var c=r();return c===n?this:(++s.value,mergeLeaves(e,o,this.hash,this,a,Leaf(e,a,l,c)))},Collision__modify=function(e,t,o,r,i,a,l){if(i===this.hash){var s=updateCollisionList(canEditNode(e,this),e,t,this.hash,this.children,r,a,l);return s===this.children?this:s.length>1?Collision(e,this.hash,s):s[0]}var u=r();return u===n?this:(++l.value,mergeLeaves(e,o,this.hash,this,i,Leaf(e,i,a,u)))},IndexedNode__modify=function(e,t,o,n,r,a,l){var s,u=this.mask,c=this.children,d=hashFragment(o,r),f=toBitmap(d),h=fromBitmap(u,f),p=u&f,_=p?c[h]:i,R=_._modify(e,t,o+5,n,r,a,l);if(_===R)return this;var S=canEditNode(e,this),y=u,m=void 0;if(p&&isEmptyNode(R)){if(!(y&=~f))return i;if(c.length<=2&&((s=c[1^h])===i||1===s.type||2===s.type))return c[1^h];m=arraySpliceOut(S,h,c)}else if(p||isEmptyNode(R))m=arrayUpdate(S,h,R,c);else{if(c.length>=16)return expand(e,d,R,u,c);y|=f,m=arraySpliceIn(S,h,R,c)}return S?(this.mask=y,this.children=m,this):IndexedNode(e,y,m)},ArrayNode__modify=function(e,t,o,n,r,a,l){var s=this.size,u=this.children,c=hashFragment(o,r),d=u[c],f=(d||i)._modify(e,t,o+5,n,r,a,l);if(d===f)return this;var h=canEditNode(e,this),p=void 0;if(isEmptyNode(d)&&!isEmptyNode(f))++s,p=arrayUpdate(h,c,f,u);else if(!isEmptyNode(d)&&isEmptyNode(f)){if(--s<=8)return pack(e,s,c,u);p=arrayUpdate(h,c,i,u)}else p=arrayUpdate(h,c,f,u);return h?(this.size=s,this.children=p,this):ArrayNode(e,s,p)};function Map(e,t,o,n,r){this._editable=e,this._edit=t,this._config=o,this._root=n,this._size=r}i._modify=function(e,t,o,r,a,l,s){var u=r();return u===n?i:(++s.value,Leaf(e,a,l,u))},Map.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new Map(this._editable,this._edit,this._config,e,t)};var a=o.tryGetHash=function(e,t,o,n){for(var r=n._root,i=0,a=n._config.keyEq;;)switch(r.type){case 1:return a(o,r.key)?r.value:e;case 2:if(t===r.hash)for(var l=r.children,s=0,u=l.length;s<u;++s){var c=l[s];if(a(o,c.key))return c.value}return e;case 3:var d=toBitmap(hashFragment(i,t));if(r.mask&d){r=r.children[fromBitmap(r.mask,d)],i+=5;break}return e;case 4:if(r=r.children[hashFragment(i,t)]){i+=5;break}return e;default:return e}};Map.prototype.tryGetHash=function(e,t,o){return a(e,t,o,this)};var l=o.tryGet=function(e,t,o){return a(e,o._config.hash(t),t,o)};Map.prototype.tryGet=function(e,t){return l(e,t,this)};var s=o.getHash=function(e,t,o){return a(void 0,e,t,o)};Map.prototype.getHash=function(e,t){return s(e,t,this)},o.get=function(e,t){return a(void 0,t._config.hash(e),e,t)},Map.prototype.get=function(e,t){return l(t,e,this)};var u=o.has=function(e,t,o){return a(n,e,t,o)!==n};Map.prototype.hasHash=function(e,t){return u(e,t,this)};var c=o.has=function(e,t){return u(t._config.hash(e),e,t)};Map.prototype.has=function(e){return c(e,this)};var defKeyCompare=function(e,t){return e===t};o.make=function(e){return new Map(0,0,{keyEq:e&&e.keyEq||defKeyCompare,hash:e&&e.hash||r},i,0)},o.empty=o.make();var d=o.isEmpty=function(e){return e&&!!isEmptyNode(e._root)};Map.prototype.isEmpty=function(){return d(this)};var f=o.modifyHash=function(e,t,o,n){var r={value:n._size},i=n._root._modify(n._editable?n._edit:NaN,n._config.keyEq,0,e,t,o,r);return n.setTree(i,r.value)};Map.prototype.modifyHash=function(e,t,o){return f(o,e,t,this)};var h=o.modify=function(e,t,o){return f(e,o._config.hash(t),t,o)};Map.prototype.modify=function(e,t){return h(t,e,this)};var p=o.setHash=function(e,t,o,n){return f(constant(o),e,t,n)};Map.prototype.setHash=function(e,t,o){return p(e,t,o,this)};var _=o.set=function(e,t,o){return p(o._config.hash(e),e,t,o)};Map.prototype.set=function(e,t){return _(e,t,this)};var R=constant(n),S=o.removeHash=function(e,t,o){return f(R,e,t,o)};Map.prototype.removeHash=Map.prototype.deleteHash=function(e,t){return S(e,t,this)};var y=o.remove=function(e,t){return S(t._config.hash(e),e,t)};Map.prototype.remove=Map.prototype.delete=function(e){return y(e,this)};var m=o.beginMutation=function(e){return new Map(e._editable+1,e._edit+1,e._config,e._root,e._size)};Map.prototype.beginMutation=function(){return m(this)};var v=o.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};Map.prototype.endMutation=function(){return v(this)};var g=o.mutate=function(e,t){var o=m(t);return e(o),v(o)};Map.prototype.mutate=function(e){return g(e,this)};var appk=function(e){return e&&lazyVisitChildren(e[0],e[1],e[2],e[3],e[4])},lazyVisitChildren=function(e,t,o,n,r){for(;o<e;){var i=t[o++];if(i&&!isEmptyNode(i))return lazyVisit(i,n,[e,t,o,n,r])}return appk(r)},lazyVisit=function(e,t,o){switch(e.type){case 1:return{value:t(e),rest:o};case 2:case 4:case 3:var n=e.children;return lazyVisitChildren(n.length,n,0,t,o);default:return appk(o)}},b={done:!0};function MapIterator(e){this.v=e}MapIterator.prototype.next=function(){if(!this.v)return b;var e=this.v;return this.v=appk(e.rest),e},MapIterator.prototype[Symbol.iterator]=function(){return this};var visit=function(e,t){return new MapIterator(lazyVisit(e._root,t))},buildPairs=function(e){return[e.key,e.value]},T=o.entries=function(e){return visit(e,buildPairs)};Map.prototype.entries=Map.prototype[Symbol.iterator]=function(){return T(this)};var buildKeys=function(e){return e.key},w=o.keys=function(e){return visit(e,buildKeys)};Map.prototype.keys=function(){return w(this)};var buildValues=function(e){return e.value},E=o.values=Map.prototype.values=function(e){return visit(e,buildValues)};Map.prototype.values=function(){return E(this)};var A=o.fold=function(e,t,o){var n=o._root;if(1===n.type)return e(t,n.value,n.key);for(var r=[n.children],i=void 0;i=r.pop();)for(var a=0,l=i.length;a<l;){var s=i[a++];s&&s.type&&(1===s.type?t=e(t,s.value,s.key):r.push(s.children))}return t};Map.prototype.fold=function(e,t){return A(e,t,this)};var N=o.forEach=function(e,t){return A(function(o,n,r){return e(n,r,t)},null,t)};Map.prototype.forEach=function(e){return N(e,this)};var L=o.count=function(e){return e._size};Map.prototype.count=function(){return L(this)},Object.defineProperty(Map.prototype,"size",{get:Map.prototype.count}),e.exports?e.exports=o:undefined.hamt=o}(r={exports:{}},r.exports),r.exports);let BuiltInMap=class BuiltInMap{constructor(e){_defineProperty(this,"_map",void 0),this._map=new Map(null==e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return persistentMap(this)}toMap(){return new Map(this._map)}};let HashArrayMappedTrieMap=class HashArrayMappedTrieMap{constructor(e){if(_defineProperty(this,"_hamt",N.empty.beginMutation()),e instanceof HashArrayMappedTrieMap){let t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(let[t,o]of e.entries())this._hamt.set(t,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return persistentMap(this)}toMap(){return new Map(this._hamt)}};function persistentMap(e){return Recoil_gkx_OSS("recoil_hamt_2020")?new HashArrayMappedTrieMap(e):new BuiltInMap(e)}var L=Object.freeze({__proto__:null,persistentMap:{persistentMap}.persistentMap}),Recoil_differenceSets=function(e,...t){let o=new Set;e:for(let n of e){for(let e of t)if(e.has(n))continue e;o.add(n)}return o},Recoil_mapMap=function(e,t){let o=new Map;return e.forEach((e,n)=>{o.set(n,t(e,n))}),o};function mergeDepsIntoGraph(e,t,o,n){let{nodeDeps:r,nodeToNodeSubscriptions:i}=o,a=r.get(e);if(a&&n&&a!==n.nodeDeps.get(e))return;r.set(e,t);let l=null==a?t:Recoil_differenceSets(t,a);for(let t of l){i.has(t)||i.set(t,new Set);let o=Recoil_nullthrows(i.get(t));o.add(e)}if(a){let o=Recoil_differenceSets(a,t);for(let t of o){if(!i.has(t))return;let o=Recoil_nullthrows(i.get(t));o.delete(e),0===o.size&&i.delete(t)}}}var V={cloneGraph:function(e){return{nodeDeps:Recoil_mapMap(e.nodeDeps,e=>new Set(e)),nodeToNodeSubscriptions:Recoil_mapMap(e.nodeToNodeSubscriptions,e=>new Set(e))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},saveDepsToStore:function(e,t,o,n){var r,i,a,l,s;let u=o.getState();n===u.currentTree.version||n===(null===(r=u.nextTree)||void 0===r?void 0:r.version)||n===(null===(i=u.previousTree)||void 0===i?void 0:i.version)||Recoil_recoverableViolation("Tried to save dependencies to a discarded tree");let c=o.getGraph(n);if(mergeDepsIntoGraph(e,t,c),n===(null===(a=u.previousTree)||void 0===a?void 0:a.version)){let n=o.getGraph(u.currentTree.version);mergeDepsIntoGraph(e,t,n,c)}if(n===(null===(l=u.previousTree)||void 0===l?void 0:l.version)||n===u.currentTree.version){let n=null===(s=u.nextTree)||void 0===s?void 0:s.version;if(void 0!==n){let r=o.getGraph(n);mergeDepsIntoGraph(e,t,r,c)}}}};let k=0,C=0,I=0;var M={getNextTreeStateVersion:()=>k++,getNextStoreID:()=>C++,getNextComponentID:()=>I++};let{persistentMap:P}=L,{graph:O}=V,{getNextTreeStateVersion:U}=M;function makeEmptyTreeState(){let e=U();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:P(),nonvalidatedAtoms:P()}}var x={makeEmptyTreeState,makeEmptyStoreState:function(){let e=makeEmptyTreeState();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,O()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:U};let RetentionZone=class RetentionZone{};var D={RetentionZone,retentionZone:function(){return new RetentionZone}},B={setByAddingToSet:function(e,t){let o=new Set(e);return o.add(t),o},setByDeletingFromSet:function(e,t){let o=new Set(e);return o.delete(t),o},mapBySettingInMap:function(e,t,o){let n=new Map(e);return n.set(t,o),n},mapByUpdatingInMap:function(e,t,o){let n=new Map(e);return n.set(t,o(n.get(t))),n},mapByDeletingFromMap:function(e,t){let o=new Map(e);return o.delete(t),o},mapByDeletingMultipleFromMap:function(e,t){let o=new Map(e);return t.forEach(e=>o.delete(e)),o}},Recoil_filterIterable=function*(e,t){let o=0;for(let n of e)t(n,o++)&&(yield n)},Recoil_lazyProxy=function(e,t){let o=new Proxy(e,{get:(e,o)=>(!(o in e)&&o in t&&(e[o]=t[o]()),e[o]),ownKeys:e=>Object.keys(e)});return o};let{getNode:F,getNodeMaybe:z,recoilValuesForKeys:W}=A,{RetentionZone:G}=D,{setByAddingToSet:$}=B,H=Object.freeze(new Set);let ReadOnlyRecoilValueError=class ReadOnlyRecoilValueError extends Error{};function initializeNodeIfNewToStore(e,t,o,n){let r=e.getState();if(r.nodeCleanupFunctions.has(o))return;let i=F(o),a=function(e,t,o){if(!Recoil_gkx_OSS("recoil_memory_managament_2020"))return()=>void 0;let{nodesRetainedByZone:n}=e.getState().retention;function addToZone(e){let o=n.get(e);o||n.set(e,o=new Set),o.add(t)}if(o instanceof G)addToZone(o);else if(Array.isArray(o))for(let e of o)addToZone(e);return()=>{if(!Recoil_gkx_OSS("recoil_memory_managament_2020"))return;let{retention:n}=e.getState();function deleteFromZone(e){let o=n.nodesRetainedByZone.get(e);null==o||o.delete(t),o&&0===o.size&&n.nodesRetainedByZone.delete(e)}if(o instanceof G)deleteFromZone(o);else if(Array.isArray(o))for(let e of o)deleteFromZone(e)}}(e,o,i.retainedBy),l=i.init(e,t,n);r.nodeCleanupFunctions.set(o,()=>{l(),a()})}function peekNodeLoadable(e,t,o){return F(o).peek(e,t)}function getDownstreamNodes(e,t,o){let n=new Set,r=Array.from(o),i=e.getGraph(t.version);for(let e=r.pop();e;e=r.pop()){var a;n.add(e);let t=null!==(a=i.nodeToNodeSubscriptions.get(e))&&void 0!==a?a:H;for(let e of t)n.has(e)||r.push(e)}return n}var K={getNodeLoadable:function(e,t,o){return initializeNodeIfNewToStore(e,t,o,"get"),F(o).get(e,t)},peekNodeLoadable,setNodeValue:function(e,t,o,n){let r=F(o);if(null==r.set)throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${o}`);let i=r.set;return initializeNodeIfNewToStore(e,t,o,"set"),i(e,t,n)},initializeNode:function(e,t,o){initializeNodeIfNewToStore(e,e.getState().currentTree,t,o)},cleanUpNode:function(e,t){var o;let n=e.getState();null===(o=n.nodeCleanupFunctions.get(t))||void 0===o||o(),n.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,o){var n;let r=z(t);return null==r||null===(n=r.invalidate)||void 0===n||n.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,o),dirtyAtoms:$(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,o){let n=e.getState(),r=e.getGraph(t.version),i=F(o).nodeType;return Recoil_lazyProxy({type:i},{loadable:()=>peekNodeLoadable(e,t,o),isActive:()=>n.knownAtoms.has(o)||n.knownSelectors.has(o),isSet:()=>"selector"!==i&&t.atomValues.has(o),isModified:()=>t.dirtyAtoms.has(o),deps:()=>{var e;return W(null!==(e=r.nodeDeps.get(o))&&void 0!==e?e:[])},subscribers:()=>{var r,i;return{nodes:W(Recoil_filterIterable(getDownstreamNodes(e,t,new Set([o])),e=>e!==o)),components:Recoil_mapIterable(null!==(r=null===(i=n.nodeToComponentSubscriptions.get(o))||void 0===i?void 0:i.values())&&void 0!==r?r:[],([e])=>({name:e}))}}})},getDownstreamNodes};let q=null;var j={setInvalidateMemoizedSnapshot:function(e){q=e},invalidateMemoizedSnapshot:function(){var e;null===(e=q)||void 0===e||e()}};let{getDownstreamNodes:Z,getNodeLoadable:Y,setNodeValue:J}=K,{getNextComponentID:X}=M,{getNode:Q,getNodeMaybe:ee}=A,{DefaultValue:et}=A,{reactMode:eo}=y,{AbstractRecoilValue:en,RecoilState:er,RecoilValueReadOnly:ei,isRecoilValue:ea}=v,{invalidateMemoizedSnapshot:el}=j;function writeLoadableToTreeState(e,t,o){"hasValue"===o.state&&o.contents instanceof et?e.atomValues.delete(t):e.atomValues.set(t,o),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function applyActionsToStore(e,t){e.replaceState(o=>{let n=copyTreeState(o);for(let o of t)!function(e,t,o){if("set"===o.type){let{recoilValue:n,valueOrUpdater:r}=o,i=function(e,t,{key:o},n){if("function"!=typeof n)return n;{let r=Y(e,t,o);if("loading"===r.state){let e=`Tried to set atom or selector "${o}" using an updater function while the current state is pending, this is not currently supported.`;throw Recoil_recoverableViolation(e),Recoil_err(e)}if("hasError"===r.state)throw r.contents;return n(r.contents)}}(e,t,n,r),a=J(e,t,n.key,i);for(let[e,o]of a.entries())writeLoadableToTreeState(t,e,o)}else if("setLoadable"===o.type){let{recoilValue:{key:e},loadable:n}=o;writeLoadableToTreeState(t,e,n)}else if("markModified"===o.type){let{recoilValue:{key:e}}=o;t.dirtyAtoms.add(e)}else if("setUnvalidated"===o.type){var n;let{recoilValue:{key:e},unvalidatedValue:r}=o,i=ee(e);null==i||null===(n=i.invalidate)||void 0===n||n.call(i,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else Recoil_recoverableViolation(`Unknown action ${o.type}`)}(e,n,o);return invalidateDownstreams(e,n),el(),n})}function queueOrPerformStateUpdate(e,t){if(es.length){let o=es[es.length-1],n=o.get(e);n||o.set(e,n=[]),n.push(t)}else applyActionsToStore(e,[t])}let es=[];function copyTreeState(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function invalidateDownstreams(e,t){let o=Z(e,t,t.dirtyAtoms);for(let e of o){var n,r;null===(n=ee(e))||void 0===n||null===(r=n.invalidate)||void 0===r||r.call(n,t)}}function setRecoilValue(e,t,o){queueOrPerformStateUpdate(e,{type:"set",recoilValue:t,valueOrUpdater:o})}var eu={RecoilValueReadOnly:ei,AbstractRecoilValue:en,RecoilState:er,getRecoilValueAsLoadable:function(e,{key:t},o=e.getState().currentTree){var n,r;let i=e.getState();o.version===i.currentTree.version||o.version===(null===(n=i.nextTree)||void 0===n?void 0:n.version)||o.version===(null===(r=i.previousTree)||void 0===r?void 0:r.version)||Recoil_recoverableViolation("Tried to read from a discarded tree");let a=Y(e,o,t);return"loading"===a.state&&a.contents.catch(()=>{}),a},setRecoilValue,setRecoilValueLoadable:function(e,t,o){if(o instanceof et)return setRecoilValue(e,t,o);queueOrPerformStateUpdate(e,{type:"setLoadable",recoilValue:t,loadable:o})},markRecoilValueModified:function(e,t){queueOrPerformStateUpdate(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,o){queueOrPerformStateUpdate(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:o})},subscribeToRecoilValue:function(e,{key:t},o,n=null){let r=X(),i=e.getState();i.nodeToComponentSubscriptions.has(t)||i.nodeToComponentSubscriptions.set(t,new Map),Recoil_nullthrows(i.nodeToComponentSubscriptions.get(t)).set(r,[null!=n?n:"<not captured>",o]);let a=eo();if(a.early&&("LEGACY"===a.mode||"MUTABLE_SOURCE"===a.mode)){let n=e.getState().nextTree;n&&n.dirtyAtoms.has(t)&&o(n)}return{release:()=>{let o=e.getState(),n=o.nodeToComponentSubscriptions.get(t);if(void 0===n||!n.has(r)){Recoil_recoverableViolation(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`);return}n.delete(r),0===n.size&&o.nodeToComponentSubscriptions.delete(t)}}},isRecoilValue:ea,applyAtomValueWrites:function(e,t){let o=e.clone();return t.forEach((e,t)=>{"hasValue"===e.state&&e.contents instanceof et?o.delete(t):o.set(t,e)}),o},batchStart:function(){let e=new Map;return es.push(e),()=>{for(let[t,o]of e)applyActionsToStore(t,o);let t=es.pop();t!==e&&Recoil_recoverableViolation("Incorrect order of batch popping")}},writeLoadableToTreeState,invalidateDownstreams,copyTreeState,refreshRecoilValue:function(e,t){var o;let{currentTree:n}=e.getState(),r=Q(t.key);null===(o=r.clearCache)||void 0===o||o.call(r,e,n)}},Recoil_someSet=function(e,t,o){let n=e.entries(),r=n.next();for(;!r.done;){let i=r.value;if(t.call(o,i[1],i[0],e))return!0;r=n.next()}return!1};let{cleanUpNode:ec}=K,{deleteNodeConfigIfPossible:ed,getNode:ef}=A,{RetentionZone:eh}=D,ep=new Set;function releaseRetainablesNowOnCurrentTree(e,t){let o=e.getState(),n=o.currentTree;if(o.nextTree){Recoil_recoverableViolation("releaseNodesNowOnCurrentTree should only be called at the end of a batch");return}let r=new Set;for(let e of t)if(e instanceof eh)for(let t of function(e,t){var o;return null!==(o=e.retention.nodesRetainedByZone.get(t))&&void 0!==o?o:ep}(o,e))r.add(t);else r.add(e);let i=function(e,t){let o=e.getState(),n=o.currentTree,r=e.getGraph(n.version),i=new Set,a=new Set;return function findReleasableNodesInner(t){var l,s;let u=new Set,c=function(e,t,o,n,r){let i=e.getGraph(t.version),a=[],l=new Set;for(;o.size>0;)(function visit(e){if(n.has(e)||r.has(e)){o.delete(e);return}if(l.has(e))return;let t=i.nodeToNodeSubscriptions.get(e);if(t)for(let e of t)visit(e);l.add(e),o.delete(e),a.push(e)})(Recoil_nullthrows(o.values().next().value));return a}(e,n,t,i,a);for(let e of c){if("recoilRoot"===ef(e).retainedBy||(null!==(l=o.retention.referenceCounts.get(e))&&void 0!==l?l:0)>0||zonesThatCouldRetainNode(e).some(e=>o.retention.referenceCounts.get(e))){a.add(e);continue}let t=r.nodeToNodeSubscriptions.get(e);if(t&&Recoil_someSet(t,e=>a.has(e))){a.add(e);continue}i.add(e),u.add(e)}let d=new Set;for(let e of u)for(let t of null!==(s=r.nodeDeps.get(e))&&void 0!==s?s:ep)i.has(t)||d.add(t);d.size&&findReleasableNodesInner(d)}(t),i}(e,r);for(let t of i)!function(e,t,o){var n,r;if(!Recoil_gkx_OSS("recoil_memory_managament_2020"))return;ec(e,o);let i=e.getState();i.knownAtoms.delete(o),i.knownSelectors.delete(o),i.nodeTransactionSubscriptions.delete(o),i.retention.referenceCounts.delete(o);let a=zonesThatCouldRetainNode(o);for(let e of a)null===(n=i.retention.nodesRetainedByZone.get(e))||void 0===n||n.delete(o);t.atomValues.delete(o),t.dirtyAtoms.delete(o),t.nonvalidatedAtoms.delete(o);let l=i.graphsByVersion.get(t.version);if(l){let e=l.nodeDeps.get(o);if(void 0!==e)for(let t of(l.nodeDeps.delete(o),e))null===(r=l.nodeToNodeSubscriptions.get(t))||void 0===r||r.delete(o);l.nodeToNodeSubscriptions.delete(o)}ed(o)}(e,n,t)}function zonesThatCouldRetainNode(e){let t=ef(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof eh?[t]:t}function updateRetainCountToZero(e,t){if(!Recoil_gkx_OSS("recoil_memory_managament_2020"))return;let o=e.getState().retention.referenceCounts;o.delete(t),function(e,t){let o=e.getState();o.nextTree?o.retention.retainablesToCheckForRelease.add(t):releaseRetainablesNowOnCurrentTree(e,new Set([t]))}(e,t)}var e_={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function(e,t,o){var n;if(!Recoil_gkx_OSS("recoil_memory_managament_2020"))return;let r=e.getState().retention.referenceCounts,i=(null!==(n=r.get(t))&&void 0!==n?n:0)+o;0===i?updateRetainCountToZero(e,t):r.set(t,i)},updateRetainCountToZero,releaseScheduledRetainablesNow:function(e){if(!Recoil_gkx_OSS("recoil_memory_managament_2020"))return;let t=e.getState();releaseRetainablesNowOnCurrentTree(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};let{unstable_batchedUpdates:eR}=u,{unstable_batchedUpdates:eS}={unstable_batchedUpdates:eR},{batchStart:ey}=eu,{unstable_batchedUpdates:em}={unstable_batchedUpdates:eS},ev=em||(e=>e());var eg={getBatcher:()=>ev,setBatcher:e=>{ev=e},batchUpdates:e=>{ev(()=>{let batchEnd=()=>void 0;try{batchEnd=ey(),e()}finally{batchEnd()}})}},Recoil_concatIterables=function*(e){for(let t of e)for(let e of t)yield e};let eb="undefined"==typeof Window||"undefined"==typeof window,eT="undefined"!=typeof navigator&&"ReactNative"===navigator.product;var ew={isSSR:eb,isReactNative:eT,isWindow:e=>!eb&&(e===window||e instanceof Window)};let{batchUpdates:eE}=eg,{initializeNode:eA,peekNodeInfo:eN}=K,{graph:eL}=V,{getNextStoreID:eV}=M,{DEFAULT_VALUE:ek,recoilValues:eC,recoilValuesForKeys:eI}=A,{AbstractRecoilValue:eM,getRecoilValueAsLoadable:eP,setRecoilValue:eO,setUnvalidatedRecoilValue:eU}=eu,{updateRetainCount:ex}=e_,{setInvalidateMemoizedSnapshot:eD}=j,{getNextTreeStateVersion:eB,makeEmptyStoreState:eF}=x,{isSSR:ez}=ew,{memoizeOneWithArgsHashAndInvalidation:eW}={memoizeWithArgsHash:function(e,t){let o;return(...n)=>{o||(o={});let r=t(...n);return Object.hasOwnProperty.call(o,r)||(o[r]=e(...n)),o[r]}},memoizeOneWithArgsHash:function(e,t){let o,n;return(...r)=>{let i=t(...r);return o===i?n:(o=i,n=e(...r))}},memoizeOneWithArgsHashAndInvalidation:function(e,t){let o,n;return[(...r)=>{let i=t(...r);return o===i?n:(o=i,n=e(...r))},()=>{o=null}]}};let Snapshot=class Snapshot{constructor(e,t){for(let o of(_defineProperty(this,"_store",void 0),_defineProperty(this,"_refCount",1),_defineProperty(this,"getLoadable",e=>(this.checkRefCount_INTERNAL(),eP(this._store,e))),_defineProperty(this,"getPromise",e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise())),_defineProperty(this,"getNodes_UNSTABLE",e=>{if(this.checkRefCount_INTERNAL(),(null==e?void 0:e.isModified)===!0){if((null==e?void 0:e.isInitialized)===!1)return[];let t=this._store.getState().currentTree;return eI(t.dirtyAtoms)}let t=this._store.getState().knownAtoms,o=this._store.getState().knownSelectors;return(null==e?void 0:e.isInitialized)==null?eC.values():!0===e.isInitialized?eI(Recoil_concatIterables([t,o])):Recoil_filterIterable(eC.values(),({key:e})=>!t.has(e)&&!o.has(e))}),_defineProperty(this,"getInfo_UNSTABLE",({key:e})=>(this.checkRefCount_INTERNAL(),eN(this._store,this._store.getState().currentTree,e))),_defineProperty(this,"map",e=>{this.checkRefCount_INTERNAL();let t=new MutableSnapshot(this,eE);return e(t),t}),_defineProperty(this,"asyncMap",async e=>{this.checkRefCount_INTERNAL();let t=new MutableSnapshot(this,eE);return t.retain(),await e(t),t.autoRelease_INTERNAL(),t}),this._store={storeID:eV(),parentStoreID:t,getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{let o=e.graphsByVersion;if(o.has(t))return Recoil_nullthrows(o.get(t));let n=eL();return o.set(t,n),n},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw Recoil_err("Cannot subscribe to Snapshots")}},this._store.getState().knownAtoms))eA(this._store,o,"get"),ex(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&Recoil_recoverableViolation("Attempt to retain() Snapshot that was already released."),this._refCount++;let e=!1;return()=>{e||(e=!0,this._release())}}autoRelease_INTERNAL(){ez||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,0===this._refCount){if(this._store.getState().nodeCleanupFunctions.forEach(e=>e()),this._store.getState().nodeCleanupFunctions.clear(),!Recoil_gkx_OSS("recoil_memory_managament_2020"))return}else this._refCount}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){Recoil_gkx_OSS("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}};function cloneStoreState(e,t,o=!1){let n=e.getState(),r=o?eB():t.version;return{currentTree:{version:o?r:t.version,stateID:o?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(n.knownAtoms),knownSelectors:new Set(n.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(Recoil_mapIterable(n.nodeCleanupFunctions.entries(),([e])=>[e,()=>{}]))}}let[eG,e$]=eW((e,t)=>{var o;let n=e.getState(),r="latest"===t?null!==(o=n.nextTree)&&void 0!==o?o:n.currentTree:Recoil_nullthrows(n.previousTree);return new Snapshot(cloneStoreState(e,r),e.storeID)},(e,t)=>{var o,n;return String(t)+String(e.storeID)+String(null===(o=e.getState().nextTree)||void 0===o?void 0:o.version)+String(e.getState().currentTree.version)+String(null===(n=e.getState().previousTree)||void 0===n?void 0:n.version)});eD(e$);let MutableSnapshot=class MutableSnapshot extends Snapshot{constructor(e,t){super(cloneStoreState(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0),e.getStoreID()),_defineProperty(this,"_batch",void 0),_defineProperty(this,"set",(e,t)=>{this.checkRefCount_INTERNAL();let o=this.getStore_INTERNAL();this._batch(()=>{ex(o,e.key,1),eO(this.getStore_INTERNAL(),e,t)})}),_defineProperty(this,"reset",e=>{this.checkRefCount_INTERNAL();let t=this.getStore_INTERNAL();this._batch(()=>{ex(t,e.key,1),eO(this.getStore_INTERNAL(),e,ek)})}),_defineProperty(this,"setUnvalidatedAtomValues_DEPRECATED",e=>{this.checkRefCount_INTERNAL();let t=this.getStore_INTERNAL();eE(()=>{for(let[o,n]of e.entries())ex(t,o,1),eU(t,new eM(o),n)})}),this._batch=t}};var eH={Snapshot,MutableSnapshot,freshSnapshot:function(e){let t=new Snapshot(eF());return null!=e?t.map(e):t},cloneSnapshot:function(e,t="latest"){let o=eG(e,t);return o.isRetained()?o:(e$(),eG(e,t))}},eK=Object.freeze({__proto__:null,Snapshot:eH.Snapshot,MutableSnapshot:eH.MutableSnapshot,freshSnapshot:eH.freshSnapshot,cloneSnapshot:eH.cloneSnapshot}),Recoil_unionSets=function(...e){let t=new Set;for(let o of e)for(let e of o)t.add(e);return t};let{useRef:eq}=s;var Recoil_useRefInitOnce=function(e){let t=eq(e);return t.current===e&&"function"==typeof e&&(t.current=e()),t};let{getNextTreeStateVersion:ej,makeEmptyStoreState:eZ}=x,{cleanUpNode:eY,getDownstreamNodes:eJ,initializeNode:eX,setNodeValue:eQ,setUnvalidatedAtomValue_DEPRECATED:e0}=K,{graph:e1}=V,{cloneGraph:e2}=V,{getNextStoreID:e5}=M,{createMutableSource:e8,reactMode:e4}=y,{applyAtomValueWrites:e3}=eu,{releaseScheduledRetainablesNow:e6}=e_,{freshSnapshot:e9}=eK,{useCallback:e7,useContext:te,useEffect:tt,useMemo:to,useRef:tn,useState:tr}=s;function notInAContext(){throw Recoil_err("This component must be used inside a <RecoilRoot> component.")}let ti=Object.freeze({storeID:e5(),getState:notInAContext,replaceState:notInAContext,getGraph:notInAContext,subscribeToTransactions:notInAContext,addTransactionMetadata:notInAContext}),ta=!1;function startNextTreeIfNeeded(e){if(ta)throw Recoil_err("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");let t=e.getState();if(null===t.nextTree){Recoil_gkx_OSS("recoil_memory_managament_2020")&&Recoil_gkx_OSS("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&e6(e);let o=t.currentTree.version,n=ej();t.nextTree={...t.currentTree,version:n,stateID:n,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(n,e2(Recoil_nullthrows(t.graphsByVersion.get(o))))}}let tl=s.createContext({current:ti}),useStoreRef=()=>te(tl),ts=s.createContext(null);function notifyComponents(e,t,o){let n=eJ(e,o,o.dirtyAtoms);for(let e of n){let n=t.nodeToComponentSubscriptions.get(e);if(n)for(let[e,[t,r]]of n)r(o)}}function sendEndOfBatchNotifications(e){let t=e.getState(),o=t.currentTree,n=o.dirtyAtoms;if(n.size){for(let[o,r]of t.nodeTransactionSubscriptions)if(n.has(o))for(let[t,o]of r)o(e);for(let[o,n]of t.transactionSubscriptions)n(e);(!e4().early||t.suspendedComponentResolvers.size>0)&&(notifyComponents(e,t,o),t.suspendedComponentResolvers.forEach(e=>e()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(e=>e(o)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Batcher({setNotifyBatcherOfChange:e}){let t=useStoreRef(),[,o]=tr([]);return e(()=>o({})),tt(()=>(e(()=>o({})),()=>{e(()=>{})}),[e]),tt(()=>{(function(e){let t=e.getState();t.commitDepth++;try{let{nextTree:o}=t;if(null==o)return;t.previousTree=t.currentTree,t.currentTree=o,t.nextTree=null,sendEndOfBatchNotifications(e),null!=t.previousTree?t.graphsByVersion.delete(t.previousTree.version):Recoil_recoverableViolation("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,Recoil_gkx_OSS("recoil_memory_managament_2020")&&null==o&&e6(e)}finally{t.commitDepth--}})(t.current)}),null}let tu=0;function RecoilRoot_INTERNAL({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:o,children:n}){let r;let getGraph=e=>{let t=r.current.graphsByVersion;if(t.has(e))return Recoil_nullthrows(t.get(e));let o=e1();return t.set(e,o),o},subscribeToTransactions=(e,t)=>{if(null==t){let{transactionSubscriptions:t}=l.current.getState(),o=tu++;return t.set(o,e),{release:()=>{t.delete(o)}}}{let{nodeTransactionSubscriptions:o}=l.current.getState();o.has(t)||o.set(t,new Map);let n=tu++;return Recoil_nullthrows(o.get(t)).set(n,e),{release:()=>{let e=o.get(t);e&&(e.delete(n),0===e.size&&o.delete(t))}}}},addTransactionMetadata=e=>{for(let t of(startNextTreeIfNeeded(l.current),Object.keys(e)))Recoil_nullthrows(l.current.getState().nextTree).transactionMetadata[t]=e[t]},replaceState=e=>{let t;startNextTreeIfNeeded(l.current);let o=Recoil_nullthrows(r.current.nextTree);try{ta=!0,t=e(o)}finally{ta=!1}t!==o&&(r.current.nextTree=t,e4().early&&notifyComponents(l.current,r.current,t),Recoil_nullthrows(i.current)())},i=tn(null),a=e7(e=>{i.current=e},[i]),l=Recoil_useRefInitOnce(()=>null!=o?o:{storeID:e5(),getState:()=>r.current,replaceState,getGraph,subscribeToTransactions,addTransactionMetadata});null!=o&&(l.current=o),r=Recoil_useRefInitOnce(()=>null!=e?function(e,t){let o=eZ();return t({set:(t,n)=>{let r=o.currentTree,i=eQ(e,r,t.key,n),a=new Set(i.keys()),l=r.nonvalidatedAtoms.clone();for(let e of a)l.delete(e);o.currentTree={...r,dirtyAtoms:Recoil_unionSets(r.dirtyAtoms,a),atomValues:e3(r.atomValues,i),nonvalidatedAtoms:l}},setUnvalidatedAtomValues:e=>{e.forEach((e,t)=>{o.currentTree=e0(o.currentTree,t,e)})}}),o}(l.current,e):null!=t?function(e){let t=e9(e),o=t.getStore_INTERNAL().getState();return t.retain(),o.nodeCleanupFunctions.forEach(e=>e()),o.nodeCleanupFunctions.clear(),o}(t):eZ());let u=to(()=>null==e8?void 0:e8(r,()=>r.current.currentTree.version),[r]);return tt(()=>{let e=l.current;for(let t of new Set(e.getState().knownAtoms))eX(e,t,"get");return()=>{for(let t of e.getState().knownAtoms)eY(e,t)}},[l]),s.createElement(tl.Provider,{value:l},s.createElement(ts.Provider,{value:u},s.createElement(Batcher,{setNotifyBatcherOfChange:a}),n))}var tc={RecoilRoot:function(e){let{override:t,...o}=e,n=useStoreRef();return!1===t&&n.current!==ti?e.children:s.createElement(RecoilRoot_INTERNAL,o)},useStoreRef,useRecoilMutableSource:function(){let e=te(ts);return null==e&&Recoil_expectationViolation("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},useRecoilStoreID:function(){return useStoreRef().current.storeID},notifyComponents_FOR_TESTING:notifyComponents,sendEndOfBatchNotifications_FOR_TESTING:sendEndOfBatchNotifications},Recoil_shallowArrayEqual=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let o=0,n=e.length;o<n;o++)if(e[o]!==t[o])return!1;return!0};let{useEffect:td,useRef:tf}=s;var Recoil_usePrevious=function(e){let t=tf();return td(()=>{t.current=e}),t.current};let{useStoreRef:th}=tc,{SUSPENSE_TIMEOUT_MS:tp}=e_,{updateRetainCount:t_}=e_,{RetentionZone:tR}=D,{useEffect:tS,useRef:ty}=s,{isSSR:tm}=ew;var Recoil_useRetain=function(e){if(Recoil_gkx_OSS("recoil_memory_managament_2020"))return function(e){let t=Array.isArray(e)?e:[e],o=t.map(e=>e instanceof tR?e:e.key),n=th();tS(()=>{if(!Recoil_gkx_OSS("recoil_memory_managament_2020"))return;let e=n.current;if(r.current&&!tm)window.clearTimeout(r.current),r.current=null;else for(let t of o)t_(e,t,1);return()=>{for(let t of o)t_(e,t,-1)}},[n,...o]);let r=ty(),i=Recoil_usePrevious(o);if(!tm&&(void 0===i||!Recoil_shallowArrayEqual(i,o))){let e=n.current;for(let t of o)t_(e,t,1);if(i)for(let t of i)t_(e,t,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{for(let t of(r.current=null,o))t_(e,t,-1)},tp)}}(e)},Recoil_useComponentName=function(){return"<component name not available>"};let{batchUpdates:tv}=eg,{DEFAULT_VALUE:tg}=A,{currentRendererSupportsUseSyncExternalStore:tb,reactMode:tT,useMutableSource:tw,useSyncExternalStore:tE}=y,{useRecoilMutableSource:tA,useStoreRef:tN}=tc,{isRecoilValue:tL}=v,{AbstractRecoilValue:tV,getRecoilValueAsLoadable:tk,setRecoilValue:tC,setUnvalidatedRecoilValue:tI,subscribeToRecoilValue:tM}=eu,{useCallback:tP,useEffect:tO,useMemo:tU,useRef:tx,useState:tD}=s,{setByAddingToSet:tB}=B,{isSSR:tF}=ew;function handleLoadable(e,t,o){if("hasValue"===e.state)return e.contents;if("loading"===e.state){let t=new Promise(t=>{let n=o.current.getState().suspendedComponentResolvers;n.add(t),tF&&Recoil_isPromise(e.contents)&&e.contents.finally(()=>{n.delete(t)})});throw t}if("hasError"===e.state)throw e.contents;throw Recoil_err(`Invalid value of loadable atom "${t.key}"`)}function useRecoilValueLoadable_SYNC_EXTERNAL_STORE(e){let t=tN(),o=Recoil_useComponentName(),n=tP(()=>{var o;let n=t.current,r=n.getState(),i=tT().early&&null!==(o=r.nextTree)&&void 0!==o?o:r.currentTree,a=tk(n,e,i);return{loadable:a,key:e.key}},[t,e]),r=tP(e=>{let t;return()=>{var o,n;let r=e();return null!==(o=t)&&void 0!==o&&o.loadable.is(r.loadable)&&(null===(n=t)||void 0===n?void 0:n.key)===r.key?t:(t=r,r)}},[]),i=tU(()=>r(n),[n,r]),a=tP(n=>{let r=t.current,i=tM(r,e,n,o);return i.release},[t,e,o]);return tE(a,i,i).loadable}function useRecoilValueLoadable_MUTABLE_SOURCE(e){let t=tN(),o=tP(()=>{var o;let n=t.current,r=n.getState(),i=tT().early&&null!==(o=r.nextTree)&&void 0!==o?o:r.currentTree;return tk(n,e,i)},[t,e]),n=tP(()=>o(),[o]),r=Recoil_useComponentName(),i=tP((n,i)=>{let a=t.current,l=tM(a,e,()=>{if(!Recoil_gkx_OSS("recoil_suppress_rerender_in_callback"))return i();let e=o();s.current.is(e)||i(),s.current=e},r);return l.release},[t,e,r,o]),a=tA();if(null==a)throw Recoil_err("Recoil hooks must be used in components contained within a <RecoilRoot> component.");let l=tw(a,n,i),s=tx(l);return tO(()=>{s.current=l}),l}function useRecoilValueLoadable_TRANSITION_SUPPORT(e){let t=tN(),o=Recoil_useComponentName(),n=tP(()=>{var o;let n=t.current,r=n.getState(),i=tT().early&&null!==(o=r.nextTree)&&void 0!==o?o:r.currentTree;return tk(n,e,i)},[t,e]),r=tP(()=>({loadable:n(),key:e.key}),[n,e.key]),i=tP(e=>{let t=r();return e.loadable.is(t.loadable)&&e.key===t.key?e:t},[r]);tO(()=>{let n=tM(t.current,e,e=>{l(i)},o);return l(i),n.release},[o,e,t,i]);let[a,l]=tD(r);return a.key!==e.key?r().loadable:a.loadable}function useRecoilValueLoadable_LEGACY(e){let t=tN(),[,o]=tD([]),n=Recoil_useComponentName(),r=tP(()=>{var o;let n=t.current,r=n.getState(),i=tT().early&&null!==(o=r.nextTree)&&void 0!==o?o:r.currentTree;return tk(n,e,i)},[t,e]),i=r(),a=tx(i);return tO(()=>{a.current=i}),tO(()=>{let i=t.current,l=i.getState(),s=tM(i,e,e=>{var t;if(!Recoil_gkx_OSS("recoil_suppress_rerender_in_callback"))return o([]);let n=r();null!==(t=a.current)&&void 0!==t&&t.is(n)||o(n),a.current=n},n);if(l.nextTree)i.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{a.current=null,o([])});else{var u;if(!Recoil_gkx_OSS("recoil_suppress_rerender_in_callback"))return o([]);let e=r();null!==(u=a.current)&&void 0!==u&&u.is(e)||o(e),a.current=e}return s.release},[n,r,e,t]),i}function useRecoilValueLoadable(e){return Recoil_gkx_OSS("recoil_memory_managament_2020")&&Recoil_useRetain(e),({TRANSITION_SUPPORT:useRecoilValueLoadable_TRANSITION_SUPPORT,SYNC_EXTERNAL_STORE:tb()?useRecoilValueLoadable_SYNC_EXTERNAL_STORE:useRecoilValueLoadable_TRANSITION_SUPPORT,MUTABLE_SOURCE:useRecoilValueLoadable_MUTABLE_SOURCE,LEGACY:useRecoilValueLoadable_LEGACY})[tT().mode](e)}function useRecoilValue(e){let t=tN(),o=useRecoilValueLoadable(e);return handleLoadable(o,e,t)}function useSetRecoilState(e){let t=tN();return tP(o=>{tC(t.current,e,o)},[t,e])}function useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(e){return Recoil_gkx_OSS("recoil_memory_managament_2020")&&Recoil_useRetain(e),useRecoilValueLoadable_TRANSITION_SUPPORT(e)}function useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(e){let t=tN(),o=useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(e);return handleLoadable(o,e,t)}var Recoil_filterMap=function(e,t){let o=new Map;for(let[n,r]of e)t(r,n)&&o.set(n,r);return o},Recoil_filterSet=function(e,t){let o=new Set;for(let n of e)t(n)&&o.add(n);return o},Recoil_mergeMaps=function(...e){let t=new Map;for(let o=0;o<e.length;o++){let n;let r=e[o].keys();for(;!(n=r.next()).done;)t.set(n.value,e[o].get(n.value))}return t};let{batchUpdates:tz}=eg,{DEFAULT_VALUE:tW,getNode:tG,nodes:t$}=A,{useStoreRef:tH}=tc,{AbstractRecoilValue:tK,setRecoilValueLoadable:tq}=eu,{SUSPENSE_TIMEOUT_MS:tj}=e_,{cloneSnapshot:tZ}=eK,{useCallback:tY,useEffect:tJ,useRef:tX,useState:tQ}=s,{isSSR:t0}=ew;function useTransactionSubscription(e){let t=tH();tJ(()=>{let o=t.current.subscribeToTransactions(e);return o.release},[e,t])}function externallyVisibleAtomValuesInState(e){let t=e.atomValues.toMap(),o=Recoil_mapMap(Recoil_filterMap(t,(e,t)=>{let o=tG(t),n=o.persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state}),e=>e.contents);return Recoil_mergeMaps(e.nonvalidatedAtoms.toMap(),o)}function gotoSnapshot(e,t){var o;let n=e.getState(),r=null!==(o=n.nextTree)&&void 0!==o?o:n.currentTree,i=t.getStore_INTERNAL().getState().currentTree;tz(()=>{let o=new Set;for(let e of[r.atomValues.keys(),i.atomValues.keys()])for(let t of e){var n,a;(null===(n=r.atomValues.get(t))||void 0===n?void 0:n.contents)!==(null===(a=i.atomValues.get(t))||void 0===a?void 0:a.contents)&&tG(t).shouldRestoreFromSnapshots&&o.add(t)}o.forEach(t=>{tq(e,new tK(t),i.atomValues.has(t)?Recoil_nullthrows(i.atomValues.get(t)):tW)}),e.replaceState(e=>({...e,stateID:t.getID()}))})}var t1={useRecoilSnapshot:function(){let e=tH(),[t,o]=tQ(()=>tZ(e.current)),n=Recoil_usePrevious(t),r=tX(),i=tX();if(useTransactionSubscription(tY(e=>o(tZ(e)),[])),tJ(()=>{let e=t.retain();if(r.current&&!t0){var o;window.clearTimeout(r.current),r.current=null,null===(o=i.current)||void 0===o||o.call(i),i.current=null}return()=>{window.setTimeout(e,10)}},[t]),n!==t&&!t0){if(r.current){var a;window.clearTimeout(r.current),r.current=null,null===(a=i.current)||void 0===a||a.call(i),i.current=null}i.current=t.retain(),r.current=window.setTimeout(()=>{var e;r.current=null,null===(e=i.current)||void 0===e||e.call(i),i.current=null},tj)}return t},gotoSnapshot,useGotoRecoilSnapshot:function(){let e=tH();return tY(t=>gotoSnapshot(e.current,t),[e])},useRecoilTransactionObserver:function(e){useTransactionSubscription(tY(t=>{let o=tZ(t,"latest"),n=tZ(t,"previous");e({snapshot:o,previousSnapshot:n})},[e]))},useTransactionObservation_DEPRECATED:function(e){useTransactionSubscription(tY(t=>{let o=t.getState().previousTree,n=t.getState().currentTree;o||(Recoil_recoverableViolation("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),o=t.getState().currentTree);let r=externallyVisibleAtomValuesInState(n),i=externallyVisibleAtomValuesInState(o),a=Recoil_mapMap(t$,e=>{var t,o,n,r;return{persistence_UNSTABLE:{type:null!==(t=null===(o=e.persistence_UNSTABLE)||void 0===o?void 0:o.type)&&void 0!==t?t:"none",backButton:null!==(n=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==n&&n}}}),l=Recoil_filterSet(n.dirtyAtoms,e=>r.has(e)||i.has(e));e({atomValues:r,previousAtomValues:i,atomInfo:a,modifiedAtoms:l,transactionMetadata:{...n.transactionMetadata}})},[e]))},useTransactionSubscription_DEPRECATED:useTransactionSubscription};let{peekNodeInfo:t2}=K,{useStoreRef:t5}=tc,{reactMode:t8}=y,{RecoilRoot:t4,useStoreRef:t3}=tc,{useMemo:t6}=s,{loadableWithValue:t9}=f,{initializeNode:t7}=K,{DEFAULT_VALUE:oe,getNode:ot}=A,{copyTreeState:oo,getRecoilValueAsLoadable:on,invalidateDownstreams:or,writeLoadableToTreeState:oi}=eu;function isAtom(e){return"atom"===ot(e.key).nodeType}let TransactionInterfaceImpl=class TransactionInterfaceImpl{constructor(e,t){_defineProperty(this,"_store",void 0),_defineProperty(this,"_treeState",void 0),_defineProperty(this,"_changes",void 0),_defineProperty(this,"get",e=>{if(this._changes.has(e.key))return this._changes.get(e.key);if(!isAtom(e))throw Recoil_err("Reading selectors within atomicUpdate is not supported");let t=on(this._store,e,this._treeState);if("hasValue"===t.state)return t.contents;if("hasError"===t.state)throw t.contents;throw Recoil_err(`Expected Recoil atom ${e.key} to have a value, but it is in a loading state.`)}),_defineProperty(this,"set",(e,t)=>{if(!isAtom(e))throw Recoil_err("Setting selectors within atomicUpdate is not supported");if("function"==typeof t){let o=this.get(e);this._changes.set(e.key,t(o))}else t7(this._store,e.key,"set"),this._changes.set(e.key,t)}),_defineProperty(this,"reset",e=>{this.set(e,oe)}),this._store=e,this._treeState=t,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;let e=oo(this._treeState);for(let[t,o]of this._changes)oi(e,t,t9(o));return or(this._store,e),e}};var oa=Object.freeze({__proto__:null,atomicUpdater:function(e){return t=>{e.replaceState(o=>{let n=new TransactionInterfaceImpl(e,o);return t(n),n.newTreeState_INTERNAL()})}}}),Recoil_invariant=function(e,t){if(!e)throw Error(t)};let{atomicUpdater:ol}=oa,{batchUpdates:os}=eg,{DEFAULT_VALUE:ou}=A,{useStoreRef:oc}=tc,{refreshRecoilValue:od,setRecoilValue:of}=eu,{cloneSnapshot:oh}=eK,{gotoSnapshot:op}=t1,{useCallback:o_}=s;let Sentinel=class Sentinel{};let oR=new Sentinel;function recoilCallback(e,t,o,n){let r,i=oR;if(os(()=>{let a="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!=typeof t)throw Recoil_err(a);let l=Recoil_lazyProxy({...null!=n?n:{},set:(t,o)=>of(e,t,o),reset:t=>of(e,t,ou),refresh:t=>od(e,t),gotoSnapshot:t=>op(e,t),transact_UNSTABLE:t=>ol(e)(t)},{snapshot:()=>{let t=oh(e);return r=t.retain(),t}}),s=t(l);if("function"!=typeof s)throw Recoil_err(a);i=s(...o)}),i instanceof Sentinel&&Recoil_invariant(!1),Recoil_isPromise(i))i=i.finally(()=>{var e;null===(e=r)||void 0===e||e()});else{var a;null===(a=r)||void 0===a||a()}return i}var oS={recoilCallback,useRecoilCallback:function(e,t){let o=oc();return o_((...t)=>recoilCallback(o.current,e,t),null!=t?[...t,o]:void 0)}};let{useStoreRef:oy}=tc,{refreshRecoilValue:om}=eu,{useCallback:ov}=s,{atomicUpdater:og}=oa,{useStoreRef:ob}=tc,{useMemo:oT}=s;var ow=Object.freeze({__proto__:null,WrappedValue:{WrappedValue:class{constructor(e){_defineProperty(this,"value",void 0),this.value=e}}}.WrappedValue});let{isFastRefreshEnabled:oE}=y;let ChangedPathError=class ChangedPathError extends Error{};var oA=Object.freeze({__proto__:null,TreeCache:{TreeCache:class{constructor(e){var t,o,n;_defineProperty(this,"_name",void 0),_defineProperty(this,"_numLeafs",void 0),_defineProperty(this,"_root",void 0),_defineProperty(this,"_onHit",void 0),_defineProperty(this,"_onSet",void 0),_defineProperty(this,"_mapNodeValue",void 0),this._name=null==e?void 0:e.name,this._numLeafs=0,this._root=null,this._onHit=null!==(t=null==e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(o=null==e?void 0:e.onSet)&&void 0!==o?o:()=>{},this._mapNodeValue=null!==(n=null==e?void 0:e.mapNodeValue)&&void 0!==n?n:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var o;return null===(o=this.getLeafNode(e,t))||void 0===o?void 0:o.value}getLeafNode(e,t){if(null==this._root)return;let o=this._root;for(;o;){if(null==t||t.onNodeVisit(o),"leaf"===o.type)return this._onHit(o),o;let n=this._mapNodeValue(e(o.nodeKey));o=o.branches.get(n)}}set(e,t,o){let addLeaf=()=>{var n,r,i,a,l,s,u;let c,d;for(let[t,n]of e){let e=this._root;if((null==e?void 0:e.type)==="leaf")throw this.invalidCacheError();let r=c;if("branch"!==(c=null!==(l=c=r?r.branches.get(d):e)&&void 0!==l?l:{type:"branch",nodeKey:t,parent:r,branches:new Map,branchKey:d}).type||c.nodeKey!==t)throw this.invalidCacheError();null==r||r.branches.set(d,c),null==o||null===(s=o.onNodeVisit)||void 0===s||s.call(o,c),d=this._mapNodeValue(n),this._root=null!==(u=this._root)&&void 0!==u?u:c}let f=c?null===(n=c)||void 0===n?void 0:n.branches.get(d):this._root;if(null!=f&&("leaf"!==f.type||f.branchKey!==d))throw this.invalidCacheError();let h={type:"leaf",value:t,parent:c,branchKey:d};null===(r=c)||void 0===r||r.branches.set(d,h),this._root=null!==(i=this._root)&&void 0!==i?i:h,this._numLeafs++,this._onSet(h),null==o||null===(a=o.onNodeVisit)||void 0===a||a.call(o,h)};try{addLeaf()}catch(e){if(e instanceof ChangedPathError)this.clear(),addLeaf();else throw e}}delete(e){let t=this.root();if(!t)return!1;if(e===t)return this._root=null,this._numLeafs=0,!0;let o=e.parent,n=e.branchKey;for(;o;){var r;if(o.branches.delete(n),o===t)return 0===o.branches.size?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;n=null===(r=o)||void 0===r?void 0:r.branchKey,o=o.parent}for(;o!==t;o=o.parent)if(null==o)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){let e=oE()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw Recoil_recoverableViolation(e+(null!=this._name?` - ${this._name}`:"")),new ChangedPathError}}}.TreeCache}),oN=Object.freeze({__proto__:null,LRUCache:{LRUCache:class{constructor(e){var t;_defineProperty(this,"_maxSize",void 0),_defineProperty(this,"_size",void 0),_defineProperty(this,"_head",void 0),_defineProperty(this,"_tail",void 0),_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){let t=this._keyMapper(e),o=this._map.get(t);if(o)return this.set(e,o.value),o.value}set(e,t){let o=this._keyMapper(e),n=this._map.get(o);n&&this.delete(e);let r=this.head(),i={key:e,right:r,left:null,value:t};r?r.left=i:this._tail=i,this._map.set(o,i),this._head=i,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){let e=this.tail();e&&this.delete(e.key)}delete(e){let t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;let o=Recoil_nullthrows(this._map.get(t)),n=o.right,r=o.left;n&&(n.left=o.left),r&&(r.right=o.right),o===this.head()&&(this._head=n),o===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}}.LRUCache});let{LRUCache:oL}=oN,{TreeCache:oV}=oA;var Recoil_treeCacheLRU=function({name:e,maxSize:t,mapNodeValue:o=e=>e}){let n=new oL({maxSize:t}),r=new oV({name:e,mapNodeValue:o,onHit:e=>{n.set(e,!0)},onSet:e=>{let o=n.tail();n.set(e,!0),o&&r.size()>t&&r.delete(o.key)}});return r};function stringify(e,t,o){if("string"==typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((null==t?void 0:t.allowFunctions)!==!0)throw Recoil_err("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";if("object"!=typeof e){var n;return null!==(n=JSON.stringify(e))&&void 0!==n?n:""}if(Recoil_isPromise(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((e,o)=>stringify(e,t,o.toString()))}]`;if("function"==typeof e.toJSON)return stringify(e.toJSON(o),t,o);if(e instanceof Map){let n={};for(let[o,r]of e)n["string"==typeof o?o:stringify(o,t)]=r;return stringify(n,t,o)}return e instanceof Set?stringify(Array.from(e).sort((e,o)=>stringify(e,t).localeCompare(stringify(o,t))),t,o):void 0!==Symbol&&null!=e[Symbol.iterator]&&"function"==typeof e[Symbol.iterator]?stringify(Array.from(e),t,o):`{${Object.keys(e).filter(t=>void 0!==e[t]).sort().map(o=>`${stringify(o,t)}:${stringify(e[o],t,o)}`).join(",")}}`}var Recoil_stableStringify=function(e,t={allowFunctions:!1}){return stringify(e,t)};let{TreeCache:ok}=oA,oC={equality:"reference",eviction:"keep-all",maxSize:1/0};var Recoil_treeCacheFromPolicy=function({equality:e=oC.equality,eviction:t=oC.eviction,maxSize:o=oC.maxSize}=oC,n){let r=function(e){switch(e){case"reference":return e=>e;case"value":return e=>Recoil_stableStringify(e)}throw Recoil_err(`Unrecognized equality policy ${e}`)}(e);return function(e,t,o,n){switch(e){case"keep-all":return new ok({name:n,mapNodeValue:o});case"lru":return Recoil_treeCacheLRU({name:n,maxSize:Recoil_nullthrows(t),mapNodeValue:o});case"most-recent":return Recoil_treeCacheLRU({name:n,maxSize:1,mapNodeValue:o})}throw Recoil_err(`Unrecognized eviction policy ${e}`)}(t,o,r,n)};let{isReactNative:oI,isWindow:oM}=ew,{isLoadable:oP,loadableWithError:oO,loadableWithPromise:oU,loadableWithValue:ox}=f,{WrappedValue:oD}=ow,{getNodeLoadable:oB,peekNodeLoadable:oF,setNodeValue:oz}=K,{saveDepsToStore:oW}=V,{DEFAULT_VALUE:oG,getConfigDeletionHandler:o$,getNode:oH,registerNode:oK}=A,{isRecoilValue:oq}=v,{markRecoilValueModified:oj}=eu,{retainedByOptionWithDefault:oZ}=e_,{recoilCallback:oY}=oS,{startPerfBlock:oJ}={startPerfBlock:function(e){return()=>null}};let Canceled=class Canceled{};let oX=new Canceled,oQ=[],o0=new Map,o1=(n=0,()=>n++);function selector(e){let t=null,{key:o,get:n,cachePolicy_UNSTABLE:r}=e,i=null!=e.set?e.set:void 0,a=new Set,l=Recoil_treeCacheFromPolicy(null!=r?r:{equality:"reference",eviction:"keep-all"},o),s=oZ(e.retainedBy_UNSTABLE),u=new Map,c=0;function selectorIsLive(){return!Recoil_gkx_OSS("recoil_memory_managament_2020")||c>0}function selectorInit(e){return e.getState().knownSelectors.add(o),c++,()=>{c--}}function selectorShouldDeleteConfigOnRelease(){return void 0!==o$(o)&&!selectorIsLive()}function notifyStoresOfResolvedAsync(e,t){isLatestExecution(e,t)&&clearExecutionInfo(e),notifyWaitingStores(t,!0)}function notifyWaitingStores(e,o){let n=o0.get(e);if(null!=n){for(let e of n)oj(e,Recoil_nullthrows(t));o&&o0.delete(e)}}function markStoreWaitingForResolvedAsync(e,t){let o=o0.get(t);null==o&&o0.set(t,o=new Set),o.add(e)}function wrapPendingDependencyPromise(e,t,o,n,r,i){return t.then(n=>{if(!selectorIsLive())throw clearExecutionInfo(e),oX;null!=i.loadingDepKey&&i.loadingDepPromise===t?o.atomValues.set(i.loadingDepKey,ox(n)):e.getState().knownSelectors.forEach(e=>{o.atomValues.delete(e)});let a=getLoadableFromCacheAndUpdateDeps(e,o);if(a&&"loading"!==a.state){if((isLatestExecution(e,r)||null==getExecutionInfo(e))&&notifyStoresOfResolvedAsync(e,r),"hasValue"===a.state)return a.contents;throw a.contents}if(!isLatestExecution(e,r)){let t=getInProgressExecutionInfo(e,o);if(null!=t)return t.loadingLoadable.contents}let[l,s]=evaluateSelectorGetter(e,o,r);if("loading"!==l.state&&(setCache(o,l,s),notifyStoresOfResolvedAsync(e,r)),"hasError"===l.state)throw l.contents;return l.contents}).catch(t=>{if(t instanceof Canceled)throw oX;if(!selectorIsLive())throw clearExecutionInfo(e),oX;let i=oO(t);throw setCache(o,i,n),notifyStoresOfResolvedAsync(e,r),t})}function updateDeps(e,t,n,r){var i,l,s,u,c,d,f;for(let h of((isLatestExecution(e,r)||t.version===(null===(i=e.getState())||void 0===i?void 0:null===(l=i.currentTree)||void 0===l?void 0:l.version)||t.version===(null===(s=e.getState())||void 0===s?void 0:null===(u=s.nextTree)||void 0===u?void 0:u.version))&&oW(o,n,e,null!==(c=null===(d=e.getState())||void 0===d?void 0:null===(f=d.nextTree)||void 0===f?void 0:f.version)&&void 0!==c?c:e.getState().currentTree.version),n))a.add(h)}function evaluateSelectorGetter(e,r,i){let a,l;let s=oJ(o),u=!0,c=!0,finishEvaluation=()=>{s(),c=!1},d=!1,f={loadingDepKey:null,loadingDepPromise:null},h=new Map;function getRecoilValue({key:t}){let o=oB(e,r,t);switch(h.set(t,o),u||(updateDeps(e,r,new Set(h.keys()),i),function(e,t){if(isLatestExecution(e,t)){let o=Recoil_nullthrows(getExecutionInfo(e));o.stateVersions.clear(),notifyWaitingStores(t,!1)}}(e,i)),o.state){case"hasValue":return o.contents;case"hasError":throw o.contents;case"loading":throw f.loadingDepKey=t,f.loadingDepPromise=o.contents,o.contents}throw Recoil_err("Invalid Loadable state")}try{(a=n({get:getRecoilValue,getCallback:o=>(...n)=>{if(c)throw Recoil_err("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return null!=t||Recoil_invariant(!1),oY(e,o,n,{node:t})}}),a=oq(a)?getRecoilValue(a):a,oP(a)&&("hasError"===a.state&&(d=!0),a=a.contents),Recoil_isPromise(a))?a=a.then(t=>{if(!selectorIsLive())throw clearExecutionInfo(e),oX;let o=ox(t);return setCache(r,o,h),notifyStoresOfResolvedAsync(e,i),t}).catch(t=>{if(!selectorIsLive())throw clearExecutionInfo(e),oX;if(Recoil_isPromise(t))return wrapPendingDependencyPromise(e,t,r,h,i,f);let o=oO(t);throw setCache(r,o,h),notifyStoresOfResolvedAsync(e,i),t}).finally(finishEvaluation):finishEvaluation(),a=a instanceof oD?a.value:a}catch(t){Recoil_isPromise(a=t)?a=wrapPendingDependencyPromise(e,a,r,h,i,f).finally(finishEvaluation):(d=!0,finishEvaluation())}return l=d?oO(a):Recoil_isPromise(a)?oU(a):ox(a),u=!1,function(e,t,o){if(isLatestExecution(e,t)){let t=getExecutionInfo(e);null!=t&&(t.depValuesDiscoveredSoFarDuringAsyncWork=o)}}(e,i,h),updateDeps(e,r,new Set(h.keys()),i),[l,h]}function getLoadableFromCacheAndUpdateDeps(e,t){let n=t.atomValues.get(o);if(null!=n)return n;let r=new Set;try{n=l.get(o=>("string"!=typeof o&&Recoil_invariant(!1),oB(e,t,o).contents),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==o&&r.add(e.nodeKey)}})}catch(e){throw Recoil_err(`Problem with cache lookup for selector "${o}": ${e.message}`)}if(n){var i;t.atomValues.set(o,n),updateDeps(e,t,r,null===(i=getExecutionInfo(e))||void 0===i?void 0:i.executionID)}return n}function getInProgressExecutionInfo(e,t){let o=Recoil_concatIterables([u.has(e)?[Recoil_nullthrows(u.get(e))]:[],Recoil_mapIterable(Recoil_filterIterable(u,([t])=>t!==e),([,e])=>e)]);for(let n of o){if(n.stateVersions.get(t.version)||!function(o){for(let[n,r]of o)if(!oB(e,t,n).is(r))return!0;return!1}(n.depValuesDiscoveredSoFarDuringAsyncWork))return n.stateVersions.set(t.version,!0),n;n.stateVersions.set(t.version,!1)}}function getExecutionInfo(e){return u.get(e)}function clearExecutionInfo(e){u.delete(e)}function isLatestExecution(e,t){var o;return t===(null===(o=getExecutionInfo(e))||void 0===o?void 0:o.executionID)}function setCache(e,t,n){e.atomValues.set(o,t);try{l.set(Array.from(n.entries()).map(([e,t])=>[e,t.contents]),t)}catch(e){throw Recoil_err(`Problem with setting cache for selector "${o}": ${e.message}`)}}function selectorPeek(e,t){let n=t.atomValues.get(o);return null!=n?n:l.get(o=>{var n;return"string"!=typeof o&&Recoil_invariant(!1),null===(n=oF(e,t,o))||void 0===n?void 0:n.contents})}function selectorGet(e,t){return function(e){if(oQ.includes(o)){let e=`Recoil selector has circular dependencies: ${oQ.slice(oQ.indexOf(o)).join(" → ")}`;return oO(Recoil_err(e))}oQ.push(o);try{return e()}finally{oQ.pop()}}(()=>(function(e,t){var o;let n=getLoadableFromCacheAndUpdateDeps(e,t);if(null!=n)return clearExecutionInfo(e),n;let r=getInProgressExecutionInfo(e,t);if(null!=r)return(null===(o=r.loadingLoadable)||void 0===o?void 0:o.state)==="loading"&&markStoreWaitingForResolvedAsync(e,r.executionID),r.loadingLoadable;let i=o1(),[a,l]=evaluateSelectorGetter(e,t,i);return"loading"===a.state?(u.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:l,executionID:i,loadingLoadable:a,stateVersions:new Map([[t.version,!0]])}),markStoreWaitingForResolvedAsync(e,i)):(clearExecutionInfo(e),setCache(t,a,l)),a})(e,t))}function invalidateSelector(e){e.atomValues.delete(o)}function clearSelectorCache(e,o){for(let r of(null!=t||Recoil_invariant(!1),a)){var n;let t=oH(r);null===(n=t.clearCache)||void 0===n||n.call(t,e,o)}a.clear(),invalidateSelector(o),l.clear(),oj(e,t)}return t=null!=i?oK({key:o,nodeType:"selector",peek:selectorPeek,get:selectorGet,set:(e,t,n)=>{let r=!1,a=new Map;function getRecoilValue({key:n}){if(r)throw Recoil_err("Recoil: Async selector sets are not currently supported.");let i=oB(e,t,n);if("hasValue"===i.state)return i.contents;if("loading"===i.state){let e=`Getting value of asynchronous atom or selector "${n}" in a pending state while setting selector "${o}" is not yet supported.`;throw Recoil_recoverableViolation(e),Recoil_err(e)}throw i.contents}function setRecoilState(o,n){if(r){let e="Recoil: Async selector sets are not currently supported.";throw Recoil_recoverableViolation(e),Recoil_err(e)}let i="function"==typeof n?n(getRecoilValue(o)):n,l=oz(e,t,o.key,i);l.forEach((e,t)=>a.set(t,e))}let l=i({set:setRecoilState,get:getRecoilValue,reset:function(e){setRecoilState(e,oG)}},n);if(void 0!==l)throw Recoil_isPromise(l)?Recoil_err("Recoil: Async selector sets are not currently supported."):Recoil_err("Recoil: selector set should be a void function.");return r=!0,a},init:selectorInit,invalidate:invalidateSelector,clearCache:clearSelectorCache,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:s}):oK({key:o,nodeType:"selector",peek:selectorPeek,get:selectorGet,init:selectorInit,invalidate:invalidateSelector,clearCache:clearSelectorCache,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:s})}selector.value=e=>new oD(e);let{isLoadable:o2,loadableWithError:o5,loadableWithPromise:o8,loadableWithValue:o4}=f,{WrappedValue:o3}=ow,{peekNodeInfo:o6}=K,{DEFAULT_VALUE:o9,DefaultValue:o7,getConfigDeletionHandler:ne,registerNode:nt,setConfigDeletionHandler:no}=A,{isRecoilValue:nn}=v,{getRecoilValueAsLoadable:nr,markRecoilValueModified:ni,setRecoilValue:na,setRecoilValueLoadable:nl}=eu,{retainedByOptionWithDefault:ns}=e_,unwrap=e=>e instanceof o3?e.value:e;function atom(e){let{...t}=e,o="default"in e?e.default:new Promise(()=>{});return nn(o)?function(e){let t=atom({...e,default:o9,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof o7?t:Recoil_nullthrows(e.persistence_UNSTABLE).validator(t,o9)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),o=selector({key:`${e.key}__withFallback`,get:({get:o})=>{let n=o(t);return n instanceof o7?e.default:n},set:({set:e},o)=>e(t,o),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return no(o.key,ne(e.key)),o}({...t,default:o}):function(e){var t;let o;let{key:n,persistence_UNSTABLE:r}=e,i=ns(e.retainedBy_UNSTABLE),a=0;function unwrapPromise(e){return o8(e.then(e=>(l=o4(e),e)).catch(e=>{throw l=o5(e),e}))}let l=Recoil_isPromise(e.default)?unwrapPromise(e.default):o2(e.default)?"loading"===e.default.state?unwrapPromise(e.default.contents):e.default:o4(unwrap(e.default));l.contents;let s=new Map;function peekAtom(e,t){var r,i;return null!==(r=null!==(i=t.atomValues.get(n))&&void 0!==i?i:o)&&void 0!==r?r:l}let u=nt({key:n,nodeType:"atom",peek:peekAtom,get:function(e,t){if(t.atomValues.has(n))return Recoil_nullthrows(t.atomValues.get(n));if(!t.nonvalidatedAtoms.has(n))return l;{if(null!=o)return o;if(null==r)return Recoil_expectationViolation(`Tried to restore a persisted value for atom ${n} but it has no persistence settings.`),l;let e=t.nonvalidatedAtoms.get(n),i=r.validator(e,o9),a=i instanceof o7?l:o4(i);return o=a}},set:function(e,t,r){if(t.atomValues.has(n)){let e=Recoil_nullthrows(t.atomValues.get(n));if("hasValue"===e.state&&r===e.contents)return new Map}else if(!t.nonvalidatedAtoms.has(n)&&r instanceof o7)return new Map;return o=void 0,new Map().set(n,o4(r))},init:function(t,o,r){var i,c,d;a++,t.getState().knownAtoms.add(n),"loading"===l.state&&l.contents.finally(()=>{var e;let o=null!==(e=t.getState().nextTree)&&void 0!==e?e:t.getState().currentTree;o.atomValues.has(n)||ni(t,u)});let f=null!==(i=e.effects)&&void 0!==i?i:e.effects_UNSTABLE;if(null!=f){let e=o9,i=!0,a=!1,h=null;function getLoadable(r){if(i&&r.key===n){let n=e;return n instanceof o7?peekAtom(t,o):Recoil_isPromise(n)?o8(n.then(e=>e instanceof o7?l.toPromise():e)):o4(n)}return nr(t,r)}function getPromise(e){return getLoadable(e).toPromise()}function getInfo_UNSTABLE(o){var r;let a=o6(t,null!==(r=t.getState().nextTree)&&void 0!==r?r:t.getState().currentTree,o.key);return!i||o.key!==n||e instanceof o7?a:{...a,isSet:!0,loadable:getLoadable(o)}}let setSelf=o=>n=>{if(i){let t=getLoadable(u),r="hasValue"===t.state?t.contents:o9;Recoil_isPromise(e="function"==typeof n?n(r):n)&&(e=e.then(e=>(h={effect:o,value:e},e)))}else{if(Recoil_isPromise(n))throw Recoil_err("Setting atoms to async values is not implemented.");"function"!=typeof n&&(h={effect:o,value:unwrap(n)}),na(t,u,"function"==typeof n?e=>{let t=unwrap(n(e));return h={effect:o,value:t},t}:unwrap(n))}},resetSelf=e=>()=>setSelf(e)(o9),onSet=e=>o=>{var r;let{release:i}=t.subscribeToTransactions(t=>{var r,i,a,s,u;let{currentTree:c,previousTree:d}=t.getState();d||(Recoil_recoverableViolation("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),d=c);let f=null!==(r=c.atomValues.get(n))&&void 0!==r?r:l;if("hasValue"===f.state){let t=f.contents,r=null!==(i=d.atomValues.get(n))&&void 0!==i?i:l,p="hasValue"===r.state?r.contents:o9;(null===(a=h)||void 0===a?void 0:a.effect)!==e||(null===(s=h)||void 0===s?void 0:s.value)!==t?o(t,p,!c.atomValues.has(n)):(null===(u=h)||void 0===u?void 0:u.effect)===e&&(h=null)}},n);s.set(t,[...null!==(r=s.get(t))&&void 0!==r?r:[],i])};for(let o of f)try{let e=o({node:u,storeID:t.storeID,parentStoreID_UNSTABLE:t.parentStoreID,trigger:r,setSelf:setSelf(o),resetSelf:resetSelf(o),onSet:onSet(o),getPromise,getLoadable,getInfo_UNSTABLE});null!=e&&s.set(t,[...null!==(c=s.get(t))&&void 0!==c?c:[],e])}catch(t){e=t,a=!0}if(i=!1,!(e instanceof o7)){let r=a?o5(e):Recoil_isPromise(e)?o8(function(e,t){let o=t.then(t=>{var r,i;let a=null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree;return(null===(i=a.atomValues.get(n))||void 0===i?void 0:i.contents)===o&&na(e,u,t),t}).catch(t=>{var r,i;let a=null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree;throw(null===(i=a.atomValues.get(n))||void 0===i?void 0:i.contents)===o&&nl(e,u,o5(t)),t});return o}(t,e)):o4(unwrap(e));r.contents,o.atomValues.set(n,r),null===(d=t.getState().nextTree)||void 0===d||d.atomValues.set(n,r)}}return()=>{var e;a--,null===(e=s.get(t))||void 0===e||e.forEach(e=>e()),s.delete(t)}},invalidate:function(){o=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==ne(n)&&a<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:i});return u}({...t,default:o})}atom.value=e=>new o3(e);var nu=Object.freeze({__proto__:null,MapCache:{MapCache:class{constructor(e){var t;_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null==e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}}}.MapCache});let{LRUCache:nc}=oN,{MapCache:nd}=nu,nf={equality:"reference",eviction:"none",maxSize:1/0};var Recoil_cacheFromPolicy=function({equality:e=nf.equality,eviction:t=nf.eviction,maxSize:o=nf.maxSize}=nf){let n=function(e){switch(e){case"reference":return e=>e;case"value":return e=>Recoil_stableStringify(e)}throw Recoil_err(`Unrecognized equality policy ${e}`)}(e),r=function(e,t,o){switch(e){case"keep-all":return new nd({mapKey:o});case"lru":return new nc({mapKey:o,maxSize:Recoil_nullthrows(t)});case"most-recent":return new nc({mapKey:o,maxSize:1})}throw Recoil_err(`Unrecognized eviction policy ${e}`)}(t,o,n);return r};let{setConfigDeletionHandler:nh}=A,{setConfigDeletionHandler:np}=A,n_=0;var Recoil_selectorFamily=function(e){var t,o;let n=Recoil_cacheFromPolicy({equality:null!==(t=null===(o=e.cachePolicyForParams_UNSTABLE)||void 0===o?void 0:o.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var o;let r,i;try{r=n.get(t)}catch(t){throw Recoil_err(`Problem with cache lookup for selector ${e.key}: ${t.message}`)}if(null!=r)return r;let a=`${e.key}__selectorFamily/${null!==(o=Recoil_stableStringify(t,{allowFunctions:!0}))&&void 0!==o?o:"void"}/${n_++}`,myGet=o=>e.get(t)(o),l=e.cachePolicy_UNSTABLE,s="function"==typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;if(null!=e.set){let o=e.set;i=selector({key:a,get:myGet,set:(e,n)=>o(t)(e,n),cachePolicy_UNSTABLE:l,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:s})}else i=selector({key:a,get:myGet,cachePolicy_UNSTABLE:l,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:s});return n.set(t,i),np(i.key,()=>{n.delete(t)}),i}};let nR=Recoil_selectorFamily({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}}),nS=Recoil_selectorFamily({key:"__error",get:e=>()=>{throw Recoil_err(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}}),{loadableWithError:ny,loadableWithPromise:nm,loadableWithValue:nv}=f;function concurrentRequests(e,t){let o=Array(t.length).fill(void 0),n=Array(t.length).fill(void 0);for(let[r,i]of t.entries())try{o[r]=e(i)}catch(e){n[r]=e}return[o,n]}function isError(e){return null!=e&&!Recoil_isPromise(e)}function unwrapDependencies(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function wrapResults(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((e,o,n)=>({...e,[o]:t[n]}),{})}function wrapLoadables(e,t,o){let n=o.map((e,o)=>null==e?nv(t[o]):Recoil_isPromise(e)?nm(e):ny(e));return wrapResults(e,n)}let ng=Recoil_selectorFamily({key:"__waitForNone",get:e=>({get:t})=>{let o=unwrapDependencies(e),[n,r]=concurrentRequests(t,o);return wrapLoadables(e,n,r)},dangerouslyAllowMutability:!0}),nb=Recoil_selectorFamily({key:"__waitForAny",get:e=>({get:t})=>{let o=unwrapDependencies(e),[n,r]=concurrentRequests(t,o);return r.some(e=>!Recoil_isPromise(e))?wrapLoadables(e,n,r):new Promise(t=>{for(let[o,i]of r.entries())Recoil_isPromise(i)&&i.then(i=>{n[o]=i,r[o]=void 0,t(wrapLoadables(e,n,r))}).catch(i=>{r[o]=i,t(wrapLoadables(e,n,r))})})},dangerouslyAllowMutability:!0}),nT=Recoil_selectorFamily({key:"__waitForAll",get:e=>({get:t})=>{let o=unwrapDependencies(e),[n,r]=concurrentRequests(t,o);if(r.every(e=>null==e))return wrapResults(e,n);let i=r.find(isError);if(null!=i)throw i;return Promise.all(r).then(t=>wrapResults(e,t.map((e,t)=>void 0===e?n[t]:e)))},dangerouslyAllowMutability:!0}),nw=Recoil_selectorFamily({key:"__waitForAllSettled",get:e=>({get:t})=>{let o=unwrapDependencies(e),[n,r]=concurrentRequests(t,o);return r.every(e=>!Recoil_isPromise(e))?wrapLoadables(e,n,r):Promise.all(r.map((e,t)=>Recoil_isPromise(e)?e.then(e=>{n[t]=e,r[t]=void 0}).catch(e=>{n[t]=void 0,r[t]=e}):null)).then(()=>wrapLoadables(e,n,r))},dangerouslyAllowMutability:!0}),nE=Recoil_selectorFamily({key:"__noWait",get:e=>({get:t})=>{try{return selector.value(nv(t(e)))}catch(e){return selector.value(Recoil_isPromise(e)?nm(e):ny(e))}},dangerouslyAllowMutability:!0}),{RecoilLoadable:nA}=f,{DefaultValue:nN}=A,{RecoilRoot:nL,useRecoilStoreID:nV}=tc,{isRecoilValue:nk}=v,{retentionZone:nC}=D,{freshSnapshot:nI}=eK,{useRecoilState:nM,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:nP,useRecoilStateLoadable:nO,useRecoilValue:nU,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:nx,useRecoilValueLoadable:nD,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:nB,useResetRecoilState:nF,useSetRecoilState:nz}={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:function(){let e=Recoil_useComponentName(),t=tN(),[,o]=tD([]),n=tx(new Set);n.current=new Set;let r=tx(new Set),i=tx(new Map),a=tP(e=>{let t=i.current.get(e);t&&(t.release(),i.current.delete(e))},[i]),l=tP((e,t)=>{i.current.has(t)&&o([])},[]);return tO(()=>{let o=t.current;Recoil_differenceSets(n.current,r.current).forEach(t=>{if(i.current.has(t)){Recoil_expectationViolation(`Double subscription to RecoilValue "${t}"`);return}let n=tM(o,new tV(t),e=>l(e,t),e);i.current.set(t,n);let r=o.getState();r.nextTree?o.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(o.getState(),t)}):l(o.getState(),t)}),Recoil_differenceSets(r.current,n.current).forEach(e=>{a(e)}),r.current=n.current}),tO(()=>{let o=i.current;return Recoil_differenceSets(n.current,new Set(o.keys())).forEach(n=>{let r=tM(t.current,new tV(n),e=>l(e,n),e);o.set(n,r)}),()=>o.forEach((e,t)=>a(t))},[e,t,a,l]),tU(()=>{function useSetRecoilState(e){return o=>{tC(t.current,e,o)}}function useRecoilValueLoadable(e){var o;n.current.has(e.key)||(n.current=tB(n.current,e.key));let r=t.current.getState();return tk(t.current,e,tT().early&&null!==(o=r.nextTree)&&void 0!==o?o:r.currentTree)}function useRecoilValue(e){let o=useRecoilValueLoadable(e);return handleLoadable(o,e,t)}return{getRecoilValue:useRecoilValue,getRecoilValueLoadable:useRecoilValueLoadable,getRecoilState:function(e){return[useRecoilValue(e),useSetRecoilState(e)]},getRecoilStateLoadable:function(e){return[useRecoilValueLoadable(e),useSetRecoilState(e)]},getSetRecoilState:useSetRecoilState,getResetRecoilState:function(e){return()=>tC(t.current,e,tg)}}},[n,t])},useRecoilState:function(e){return[useRecoilValue(e),useSetRecoilState(e)]},useRecoilStateLoadable:function(e){return[useRecoilValueLoadable(e),useSetRecoilState(e)]},useRecoilValue,useRecoilValueLoadable,useResetRecoilState:function(e){let t=tN();return tP(()=>{tC(t.current,e,tg)},[t,e])},useSetRecoilState,useSetUnvalidatedAtomValues:function(){let e=tN();return(t,o={})=>{tv(()=>{e.current.addTransactionMetadata(o),t.forEach((t,o)=>tI(e.current,new tV(o),t))})}},useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:function(e){return[useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(e),useSetRecoilState(e)]}},{useGotoRecoilSnapshot:nW,useRecoilSnapshot:nG,useRecoilTransactionObserver:n$}=t1,{useRecoilCallback:nH}=oS,{noWait:nK,waitForAll:nq,waitForAllSettled:nj,waitForAny:nZ,waitForNone:nY}={waitForNone:ng,waitForAny:nb,waitForAll:nT,waitForAllSettled:nw,noWait:nE};var nJ={DefaultValue:nN,isRecoilValue:nk,RecoilLoadable:nA,RecoilEnv:h,RecoilRoot:nL,useRecoilStoreID:nV,useRecoilBridgeAcrossReactRoots_UNSTABLE:function(){"MUTABLE_SOURCE"===t8().mode&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");let e=t3().current;return t6(()=>function({children:t}){return s.createElement(t4,{store_INTERNAL:e},t)},[e])},atom:atom,selector:selector,atomFamily:function(e){var t,o;let n=Recoil_cacheFromPolicy({equality:null!==(t=null===(o=e.cachePolicyForParams_UNSTABLE)||void 0===o?void 0:o.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var o,r;let i=n.get(t);if(null!=i)return i;let{cachePolicyForParams_UNSTABLE:a,...l}=e,s="default"in e?e.default:new Promise(()=>{}),u=atom({...l,key:`${e.key}__${null!==(o=Recoil_stableStringify(t))&&void 0!==o?o:"void"}`,default:"function"==typeof s?s(t):s,retainedBy_UNSTABLE:"function"==typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects:"function"==typeof e.effects?e.effects(t):"function"==typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):null!==(r=e.effects)&&void 0!==r?r:e.effects_UNSTABLE});return n.set(t,u),nh(u.key,()=>{n.delete(t)}),u}},selectorFamily:Recoil_selectorFamily,constSelector:function(e){return nR(e)},errorSelector:function(e){return nS(e)},readOnlySelector:function(e){return e},noWait:nK,waitForNone:nY,waitForAny:nZ,waitForAll:nq,waitForAllSettled:nj,useRecoilValue:nU,useRecoilValueLoadable:nD,useRecoilState:nM,useRecoilStateLoadable:nO,useSetRecoilState:nz,useResetRecoilState:nF,useGetRecoilValueInfo_UNSTABLE:function(){let e=t5();return({key:t})=>t2(e.current,e.current.getState().currentTree,t)},useRecoilRefresher_UNSTABLE:function(e){let t=oy();return ov(()=>{let o=t.current;om(o,e)},[e,t])},useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:nB,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:nx,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:nP,useRecoilCallback:nH,useRecoilTransaction_UNSTABLE:function(e,t){let o=ob();return oT(()=>(...t)=>{let n=og(o.current);n(o=>{e(o)(...t)})},null!=t?[...t,o]:void 0)},useGotoRecoilSnapshot:nW,useRecoilSnapshot:nG,useRecoilTransactionObserver_UNSTABLE:n$,snapshot_UNSTABLE:nI,useRetain:Recoil_useRetain,retentionZone:nC};nJ.DefaultValue,nJ.isRecoilValue,nJ.RecoilLoadable,nJ.RecoilEnv;var nX=nJ.RecoilRoot;nJ.useRecoilStoreID,nJ.useRecoilBridgeAcrossReactRoots_UNSTABLE;var nQ=nJ.atom,n0=nJ.selector;nJ.atomFamily,nJ.selectorFamily,nJ.constSelector,nJ.errorSelector,nJ.readOnlySelector,nJ.noWait,nJ.waitForNone,nJ.waitForAny,nJ.waitForAll,nJ.waitForAllSettled;var n1=nJ.useRecoilValue;nJ.useRecoilValueLoadable;var n2=nJ.useRecoilState;nJ.useRecoilStateLoadable,nJ.useSetRecoilState,nJ.useResetRecoilState,nJ.useGetRecoilValueInfo_UNSTABLE,nJ.useRecoilRefresher_UNSTABLE,nJ.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,nJ.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,nJ.useRecoilState_TRANSITION_SUPPORT_UNSTABLE,nJ.useRecoilCallback,nJ.useRecoilTransaction_UNSTABLE,nJ.useGotoRecoilSnapshot,nJ.useRecoilSnapshot,nJ.useRecoilTransactionObserver_UNSTABLE,nJ.snapshot_UNSTABLE,nJ.useRetain,nJ.retentionZone}}]);